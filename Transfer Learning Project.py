# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fxg1BA0o5etFPdMPDYBtMrFK2eJZ2nHO
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

from google.colab import drive
drive.mount('/content/drive')

# Unzip the dataset
!unzip -q "/content/images.zip"

# Read CSVs
train_df = pd.read_csv('/content/train.csv')
test_df = pd.read_csv('/content/test.csv')
sample_submission = pd.read_csv('/content/sample_submission.csv')

# Add image path
train_df['image_names'] = '/content/gender_data/image/' + train_df['image_names']
test_df['image_names'] = '/content/gender_data/image/' + test_df['image_names']

from tensorflow.keras.preprocessing.image import ImageDataGenerator
import pandas as pd # Ensure pandas is imported if not already

train_df = pd.read_csv('/content/train.csv')
train_df['image_names'] = '/content/images/' + train_df['image_names']

datagen = ImageDataGenerator(rescale=1./255, validation_split=0.2)

# Convert the 'class' column to string type
train_df['class'] = train_df['class'].astype(str)

train_generator = datagen.flow_from_dataframe(
    train_df,
    x_col='image_names',
    y_col='class',
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary',
    subset='training'
)

val_generator = datagen.flow_from_dataframe(
    train_df,
    x_col='image_names',
    y_col='class',
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary',
    subset='validation'
)

image_size = (224, 224)
batch_size = 32

datagen = ImageDataGenerator(rescale=1./255, validation_split=0.2)

# Convert the 'class' column to string type
train_df['class'] = train_df['class'].astype(str)

train_generator = datagen.flow_from_dataframe(
    train_df,
    x_col='image_names',
    y_col='class',
    target_size=image_size,
    class_mode='binary',
    batch_size=batch_size,
    subset='training',
    shuffle=True
)

val_generator = datagen.flow_from_dataframe(
    train_df,
    x_col='image_names',
    y_col='class',
    target_size=image_size,
    class_mode='binary',
    batch_size=batch_size,
    subset='validation',
    shuffle=False
)

base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze all layers first
for layer in base_model.layers:
    layer.trainable = False

# Unfreeze top 30 layers for fine-tuning
for layer in base_model.layers[-30:]:
    layer.trainable = True

# Custom classification head
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dropout(0.5)(x)
predictions = Dense(1, activation='sigmoid')(x)

model = Model(inputs=base_model.input, outputs=predictions)

model.compile(optimizer=Adam(learning_rate=1e-4), loss='binary_crossentropy', metrics=['accuracy'])
model.summary()

callbacks = [
    EarlyStopping(patience=3, restore_best_weights=True),
    ModelCheckpoint('best_model.h5', save_best_only=True)
]

history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=10,
    callbacks=callbacks
)

# Test generator
test_datagen = ImageDataGenerator(rescale=1./255)

# Reload or ensure the initial test_df is used before adding the path
# Assuming test.csv has just the image filename in the 'image_names' column initially
test_df = pd.read_csv('/content/test.csv')

# Set the correct image path in test_df based on the unzipped location
test_df['image_names'] = '/content/images/' + test_df['image_names']

# Verify the paths in the dataframe (optional, for debugging)
# print(test_df.head())
# print(os.path.exists(test_df['image_names'].iloc[0])) # Check if the first image path exists

test_generator = test_datagen.flow_from_dataframe(
    dataframe=test_df,
    x_col='image_names',
    target_size=image_size,
    batch_size=batch_size,
    class_mode=None,
    shuffle=False
)

# Add a check to see how many images were found
print(f"Found {test_generator.n} images belonging to 1 classes.")

# Predict
# Convert the result of np.ceil to an integer for the steps argument
predictions = model.predict(test_generator, steps=int(np.ceil(test_generator.n / test_generator.batch_size)))
pred_labels = (predictions > 0.5).astype(int).reshape(-1)

# Submission
submission = sample_submission.copy()
submission['class'] = pred_labels
submission.to_csv('submission.csv', index=False)





